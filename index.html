<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Тир з Змінним Прицілом</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #ffffff;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
        }

        .ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
        }

        .stats-top {
            display: flex;
            justify-content: space-between;
            width: 100%;
            font-size: 1.5rem;
            font-weight: bold;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 2px;
            background-color: #ffffff;
            box-shadow: 0 0 5px #ffffff;
            transition: opacity 0.2s;
            pointer-events: none;
        }

        .crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 2px;
            height: 20px;
            background-color: #ffffff;
        }
        
        .aiming-crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border-style: solid;
            border-color: rgba(255, 255, 255, 0.8);
            border-width: 1px;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .aiming-crosshair::before,
        .aiming-crosshair::after {
            content: '';
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
        }

        .aiming-crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 1px;
            transform: translateY(-50%);
        }

        .aiming-crosshair::after {
            top: 0;
            left: 50%;
            width: 1px;
            height: 100%;
            transform: translateX(-50%);
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(22, 27, 34, 0.95);
            border: 2px solid #238636;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            z-index: 100;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            min-width: 300px;
            box-shadow: 0 0 25px rgba(35, 134, 54, 0.9);
            animation: fadeIn 0.3s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .message-box h2 {
            font-size: 2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #238636;
        }

        .message-box p {
            font-size: 1.2rem;
            font-weight: 300;
        }

        .message-box button {
            background-color: #238636;
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 1rem;
            transition: background-color 0.3s, transform 0.1s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            pointer-events: all;
        }

        .message-box button:hover {
            background-color: #2ea043;
            transform: translateY(-2px);
        }

        .message-box button:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div id="game-canvas-container" tabindex="0"></div>
    <div class="ui-container">
        <div class="stats-top">
            <span id="score-display">Рахунок: 0</span>
            <span id="ammo-display">Набої: Нескінченні</span>
            <span id="mode-display">Режим: Одиночний</span>
            <span id="silencer-display">Глушник: Ні</span>
            <span id="zoom-display" style="opacity: 0;">Зум: 1x</span>
        </div>
        <div id="normal-crosshair" class="crosshair"></div>
        <div id="aiming-crosshair" class="aiming-crosshair"></div>
    </div>

    <div id="messageBox" class="message-box">
        <h2 id="message-title"></h2>
        <p id="message-text"></p>
        <button id="startButton">Почати гру</button>
    </div>

    <script>
        // --- Game Variables ---
        let scene, camera, renderer;
        let score = 0;
        let isGameRunning = false;
        let isAiming = false;
        let isPaused = false;
        let normalFov;
        let currentZoom = 1;
        const maxZoom = 10;
        const minZoom = 1;
        let targets = [];
        let explodingTargets = [];
        const maxTargetCount = 5;
        const spawnInterval = 2000;
        let lastSpawnTime = 0;
        const targetSpawnPositions = [
            new THREE.Vector3(0, 1.5, -10),
            new THREE.Vector3(5, 1.5, -10),
            new THREE.Vector3(-5, 1.5, -10),
            new THREE.Vector3(0, 3.5, -10),
            new THREE.Vector3(5, 3.5, -10),
            new THREE.Vector3(-5, 3.5, -10),
            new THREE.Vector3(0, 1.5, -15),
            new THREE.Vector3(5, 1.5, -15),
            new THREE.Vector3(-5, 1.5, -15),
            new THREE.Vector3(0, 3.5, -15),
        ];
        let isMouseDown = false;
        let firingMode = 'single';
        const fireRate = 100;
        let lastFireTime = 0;
        let silencer;
        let isSilencerEquipped = false;
        let muzzleFlashLight; // Додано глобальну змінну для спалаху

        // --- Character Movement Variables ---
        let keys = {};
        const moveSpeed = 0.1;
        const forwardVector = new THREE.Vector3();
        const rightVector = new THREE.Vector3();

        // --- UI Elements ---
        const messageBox = document.getElementById('messageBox');
        const messageTitle = document.getElementById('message-title');
        const messageText = document.getElementById('message-text');
        const actionButton = document.getElementById('startButton');
        const scoreDisplay = document.getElementById('score-display');
        const ammoDisplay = document.getElementById('ammo-display');
        const modeDisplay = document.getElementById('mode-display');
        const silencerDisplay = document.getElementById('silencer-display');
        const zoomDisplay = document.getElementById('zoom-display');
        const normalCrosshair = document.getElementById('normal-crosshair');
        const aimingCrosshair = document.getElementById('aiming-crosshair');

        // --- Audio Context ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        // --- Create Sounds ---
        function createShotSound() {
            const bufferSize = audioCtx.sampleRate * 0.2;
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(2000, audioCtx.currentTime);
            const gainNode = audioCtx.createGain();
            
            // Adjust gain based on silencer state
            const gainValue = isSilencerEquipped ? 0.1 : 0.5;
            gainNode.gain.setValueAtTime(gainValue, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.2);
            source.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            source.start(audioCtx.currentTime);
        }

        // --- UI Functions ---
        function updateUI() {
            scoreDisplay.textContent = `Рахунок: ${score}`;
            zoomDisplay.textContent = `Зум: ${currentZoom.toFixed(1)}x`;
        }

        function showInteractiveMessage(title, text, buttonText, buttonAction) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            actionButton.textContent = buttonText;
            actionButton.style.display = 'block';
            actionButton.onclick = buttonAction;
            messageBox.style.display = 'flex';
        }

        function showTemporaryMessage(title, text, duration = 2000) {
            messageTitle.textContent = title;
            messageText.textContent = text;
            actionButton.style.display = 'none';
            messageBox.style.display = 'flex';
            setTimeout(hideMessage, duration);
        }

        function hideMessage() {
            messageBox.style.display = 'none';
        }

        // --- Raycaster for shooting ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // --- Game Logic Functions ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            if (!isGameRunning || isPaused) return;
            const sensitivity = isAiming ? 0.002 / currentZoom : 0.002;
            camera.rotation.y -= event.movementX * sensitivity;
            camera.rotation.x -= event.movementY * sensitivity;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onKeyDown(event) {
            if (!isGameRunning) return;
            
            // Use event.code for more reliable key detection
            keys[event.code] = true;

            switch (event.code) {
                case 'Digit1':
                    toggleFiringMode();
                    break;
                case 'Digit6':
                    toggleSilencer();
                    break;
                case 'Digit9':
                    restartGame();
                    break;
                case 'KeyP':
                    togglePause();
                    break;
            }
        }

        function onKeyUp(event) {
            keys[event.code] = false;
        }

        function onMouseDown(event) {
            if (!isGameRunning || isPaused) return;
            if (event.button === 0) {
                isMouseDown = true;
                if (firingMode === 'single') {
                    shoot();
                }
            }
            // Toggle aiming with right mouse button click
            if (event.button === 2) {
                isAiming = !isAiming;
                updateAimingState();
            }
        }

        function onMouseUp(event) {
            if (!isGameRunning || isPaused) return;
            if (event.button === 0) {
                isMouseDown = false;
            }
            // No need for a separate right-click mouseup handler
        }

        function updateAimingState() {
            if (isAiming) {
                camera.fov = normalFov / currentZoom;
                camera.updateProjectionMatrix();
                normalCrosshair.style.opacity = 0;
                aimingCrosshair.style.opacity = 1;
                zoomDisplay.style.opacity = 1;
            } else {
                camera.fov = normalFov;
                camera.updateProjectionMatrix();
                normalCrosshair.style.opacity = 1;
                aimingCrosshair.style.opacity = 0;
                zoomDisplay.style.opacity = 0;
            }
        }
        
        // New event handler for mouse wheel
        function onMouseWheel(event) {
            if (!isGameRunning || isPaused || !isAiming) return;
            
            // Adjust zoom level based on scroll direction
            if (event.deltaY < 0) {
                // Zoom in
                currentZoom = Math.min(maxZoom, currentZoom + 0.5);
            } else {
                // Zoom out
                currentZoom = Math.max(minZoom, currentZoom - 0.5);
            }

            // Update camera FOV and UI
            camera.fov = normalFov / currentZoom;
            camera.updateProjectionMatrix();
            updateUI();
        }

        function shoot() {
            createShotSound();

            // Вмикаємо спалах пострілу
            muzzleFlashLight.visible = true;
            // Вимикаємо спалах через 50 мілісекунд, щоб створити ефект миттєвого спалаху
            setTimeout(() => {
                muzzleFlashLight.visible = false;
            }, 50);

            // Raycasting
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(targets);

            if (intersects.length > 0) {
                const hitTarget = intersects[0].object;
                hitTarget.hitTime = performance.now();
                score += 10;
                updateUI();
                explodingTargets.push(hitTarget);
                targets = targets.filter(t => t !== hitTarget);
            }
        }

        function toggleFiringMode() {
            if (firingMode === 'single') {
                firingMode = 'auto';
                modeDisplay.textContent = 'Режим: Автоматичний';
                showTemporaryMessage('Режим стрільби', 'Встановлено автоматичний режим.');
            } else {
                firingMode = 'single';
                modeDisplay.textContent = 'Режим: Одиночний';
                showTemporaryMessage('Режим стрільби', 'Встановлено одиночний режим.');
            }
        }

        function toggleSilencer() {
            isSilencerEquipped = !isSilencerEquipped;
            silencer.visible = isSilencerEquipped;
            silencerDisplay.textContent = `Глушник: ${isSilencerEquipped ? 'Так' : 'Ні'}`;
            showTemporaryMessage('Глушник', `Глушник ${isSilencerEquipped ? 'увімкнено' : 'вимкнено'}.`);
        }

        function togglePause() {
            isPaused = !isPaused;
            if (isPaused) {
                showInteractiveMessage('Гра призупинена', 'Натисніть "P" для продовження', 'Продовжити', togglePause);
            } else {
                hideMessage();
                requestAnimationFrame(gameLoop);
            }
        }

        function spawnTarget() {
            const geometry = new THREE.BoxGeometry(1, 1, 0.2);
            const material = new THREE.MeshPhongMaterial({ color: 0x2ea043 });
            const target = new THREE.Mesh(geometry, material);

            const pos = targetSpawnPositions[Math.floor(Math.random() * targetSpawnPositions.length)];
            target.position.set(pos.x, pos.y, pos.z);
            targets.push(target);
            scene.add(target);
        }

        function gameLoop(timestamp) {
            if (!isGameRunning || isPaused) {
                return;
            }

            // --- Handle Character Movement ---
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            direction.y = 0;
            direction.normalize();

            const right = new THREE.Vector3().crossVectors(direction, camera.up).normalize();

            // Check for movement keys using event.code
            if (keys['KeyW']) {
                camera.position.addScaledVector(direction, moveSpeed);
            }
            if (keys['KeyS']) {
                camera.position.addScaledVector(direction, -moveSpeed);
            }
            if (keys['KeyA']) {
                camera.position.addScaledVector(right, -moveSpeed);
            }
            if (keys['KeyD']) {
                camera.position.addScaledVector(right, moveSpeed);
            }

            const now = performance.now();
            if (now - lastSpawnTime > spawnInterval && targets.length + explodingTargets.length < maxTargetCount) {
                spawnTarget();
                lastSpawnTime = now;
            }

            if (isMouseDown && now - lastFireTime > fireRate && firingMode === 'auto') {
                shoot();
                lastFireTime = now;
            }

            for (let i = explodingTargets.length - 1; i >= 0; i--) {
                const target = explodingTargets[i];
                const elapsedTime = now - target.hitTime;
                if (elapsedTime > 500) {
                    scene.remove(target);
                    explodingTargets.splice(i, 1);
                } else {
                    target.scale.setScalar(1 - elapsedTime / 500);
                    target.material.color.set(0xff0000);
                }
            }

            renderer.render(scene, camera);
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            hideMessage();
            score = 0;
            isGameRunning = true;
            isAiming = false;
            isPaused = false;
            currentZoom = 1;
            camera.fov = normalFov;
            camera.updateProjectionMatrix();
            normalCrosshair.style.opacity = 1;
            aimingCrosshair.style.opacity = 0;
            zoomDisplay.style.opacity = 0;
            targets.forEach(target => scene.remove(target));
            targets = [];
            explodingTargets.forEach(target => scene.remove(target));
            explodingTargets = [];
            updateUI();
            lastSpawnTime = performance.now();
            requestAnimationFrame(gameLoop);
            // Set focus to the canvas to catch keyboard events
            document.getElementById('game-canvas-container').focus();
        }

        function restartGame() {
            if (!isGameRunning) {
                startGame();
            } else {
                hideMessage();
                score = 0;
                isAiming = false;
                isPaused = false;
                keys = {};
                currentZoom = 1;
                camera.fov = normalFov;
                camera.updateProjectionMatrix();
                normalCrosshair.style.opacity = 1;
                aimingCrosshair.style.opacity = 0;
                zoomDisplay.style.opacity = 0;
                targets.forEach(target => scene.remove(target));
                targets = [];
                explodingTargets.forEach(target => scene.remove(target));
                explodingTargets = [];
                updateUI();
                lastSpawnTime = performance.now();
                requestAnimationFrame(gameLoop);
            }
        }

        function endGame() {
            isGameRunning = false;
            showInteractiveMessage('Гра завершена!', `Ваш рахунок: ${score}`, 'Почати гру', startGame);
        }

        // --- Game Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x010409);
            scene.fog = new THREE.Fog(0x0d1117, 10, 100);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            normalFov = camera.fov;
            camera.position.set(0, 1.6, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('game-canvas-container').appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Environment: Indoor Shooting Range
            createShootingRange();

            // Weapon
            createWeapon();

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            window.addEventListener('mousedown', onMouseDown, false);
            window.addEventListener('mouseup', onMouseUp, false);
            window.addEventListener('mousemove', onMouseMove, false);
            window.addEventListener('wheel', onMouseWheel, false);
            window.addEventListener('keydown', onKeyDown, false);
            window.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('contextmenu', (e) => e.preventDefault());

            // Initial UI update
            updateUI();
            startGame();
        }

        // --- Create Indoor Shooting Range Environment ---
        function createShootingRange() {
            const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x1d212a, side: THREE.DoubleSide });
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x161b22, side: THREE.DoubleSide });

            // Floor
            const floorGeometry = new THREE.PlaneGeometry(30, 30);
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = 0;
            scene.add(floor);

            // Back Wall (where targets are)
            const backWallGeometry = new THREE.PlaneGeometry(30, 15);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 7.5, -25);
            scene.add(backWall);

            // Side Walls
            const sideWallGeometry = new THREE.PlaneGeometry(30, 15);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.position.set(-15, 7.5, 0);
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.position.set(15, 7.5, 0);
            scene.add(rightWall);

            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(30, 30);
            const ceiling = new THREE.Mesh(ceilingGeometry, wallMaterial);
            ceiling.rotation.x = -Math.PI / 2;
            ceiling.position.y = 15;
            scene.add(ceiling);
        }

        // --- Create M4A1 Model ---
        function createWeapon() {
            const gunGroup = new THREE.Group();
            const material = new THREE.MeshPhongMaterial({ color: 0x30363d });
            const blackMaterial = new THREE.MeshPhongMaterial({ color: 0x161b22 });

            // Receiver (Main body)
            const receiverGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.6);
            const receiver = new THREE.Mesh(receiverGeometry, material);
            receiver.position.set(0, 0, 0);
            gunGroup.add(receiver);

            // Magazine
            const magGeometry = new THREE.BoxGeometry(0.08, 0.25, 0.05);
            const mag = new THREE.Mesh(magGeometry, blackMaterial);
            mag.position.set(0, -0.15, 0.05);
            gunGroup.add(mag);

            // Pistol Grip
            const gripGeometry = new THREE.BoxGeometry(0.08, 0.15, 0.08);
            const grip = new THREE.Mesh(gripGeometry, blackMaterial);
            grip.position.set(0, -0.05, -0.2);
            grip.rotation.x = -Math.PI / 8;
            gunGroup.add(grip);

            // Stock
            const stockGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.4);
            const stock = new THREE.Mesh(stockGeometry, blackMaterial);
            stock.position.set(0, 0.02, -0.5);
            gunGroup.add(stock);

            // Stock end
            const stockEndGeometry = new THREE.BoxGeometry(0.15, 0.1, 0.05);
            const stockEnd = new THREE.Mesh(stockEndGeometry, blackMaterial);
            stockEnd.position.set(0, 0.05, -0.7);
            gunGroup.add(stockEnd);

            // Barrel
            const barrelGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.8, 16);
            const barrel = new THREE.Mesh(barrelGeometry, blackMaterial);
            barrel.rotation.z = Math.PI / 2;
            barrel.position.set(0, 0.03, 0.4);
            gunGroup.add(barrel);

            // Silencer
            const silencerGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.25, 16);
            silencer = new THREE.Mesh(silencerGeometry, blackMaterial);
            silencer.rotation.z = Math.PI / 2;
            silencer.position.set(0, 0.03, 0.7);
            silencer.visible = false;
            gunGroup.add(silencer);

            // Handguard
            const handguardGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 16);
            const handguard = new THREE.Mesh(handguardGeometry, material);
            handguard.rotation.z = Math.PI / 2;
            handguard.position.set(0, 0.03, 0.3);
            gunGroup.add(handguard);

            // Foregrip
            const foregripGeometry = new THREE.BoxGeometry(0.05, 0.2, 0.05);
            const foregrip = new THREE.Mesh(foregripGeometry, blackMaterial);
            foregrip.position.set(0, -0.07, 0.3);
            gunGroup.add(foregrip);

            // Додаємо спалах пострілу як світлову точку.
            // Ми додаємо його до групи зброї, щоб він рухався разом з нею.
            muzzleFlashLight = new THREE.PointLight(0xffcc00, 50, 2);
            muzzleFlashLight.position.set(0, 0.03, 0.7);
            muzzleFlashLight.visible = false;
            gunGroup.add(muzzleFlashLight);

            // Add the weapon to the camera
            gunGroup.position.set(0.2, -0.3, -0.5);
            camera.add(gunGroup);
            scene.add(camera);
        }

        window.onload = function() {
            init();
        };
    </script>
</body>
</html>